#!/usr/bin/env python3

import os
import csv
import codecs
import requests
import argparse

from contextlib import closing

__author__    = "ditekSHen"
__copyright__ = "Copyright 2020, ditekShen"
__version__   = "1.0"
__reference__ = "https://github.com/ditekshen"

FILE_URL = "https://bazaar.abuse.ch/export/csv/cscb/"

def parse_csv(infile=None):
    cert_data = list()
    if infile:
        infile = os.path.join(os.path.dirname(__file__), infile)
        try:
            with open(infile, 'r', encoding='utf-8') as csvfile:
                reader = csv.reader(csvfile, delimiter=',', quotechar='"', skipinitialspace=True)
                try:
                    for row in reader:
                        if not row[0].startswith('#'):
                            cert = dict()
                            cert["serial_number"] = row[1]
                            cert["thumbprint"] = row[2]
                            cert["subject_cn"] = row[4]
                            cert["reason"] = row[8]
                            cert_data.append(cert)
                except IndexError as err:
                    print("Input file is potentially not a CSV file")
                    raise SystemExit(err)
        except IOError as err:
            raise SystemExit(err)

        return cert_data
    else:
        try:
            with closing(requests.get(FILE_URL, stream=True)) as response:
                if response.status_code == 200:
                    reader = csv.reader(codecs.iterdecode(response.iter_lines(),'utf-8'), delimiter=',', quotechar='"', skipinitialspace=True)
                    try:
                        for row in reader:
                            if not row[0].startswith('#'):
                                cert = dict()
                                cert["serial_number"] = row[1]
                                cert["thumbprint"] = row[2]
                                cert["subject_cn"] = row[4]
                                cert["reason"] = row[8]
                                cert_data.append(cert)
                    except IndexError as err:
                        print("Response data is potentially not CSV formatted")
                        raise SystemExit(err)
        except requests.exceptions.RequestException as err:
            raise SystemExit(err)
        
        return cert_data
                    
def write_yara(iocs, outfile):
    rules = str()

    try:
        fw = open(outfile, 'w')
    except IOError:
        print("Could not open file for writting output Yara rules file")

    file_header = "/*\n"
    file_header += "    Auto-generated certificate-based Yara rules from Abuse.ch MalwareBazar Code Signing Certificate Blocklist\n"
    file_header += "    Author: Automatically generated by MBCSCBYar (ditekSHen)\n"
    file_header += "    Reference: https://bazaar.abuse.ch/faq/#cscb\n"
    file_header += "    Reference: https://github.com/ditekshen\n"
    file_header += "*/\n\n"
    fw.write(file_header)

    fw.write('import "pe"\n\n')

    for cert in iocs:
        rule_name = "rule INDICATOR_KB_CERT_%s {\n" % cert["serial_number"].lower()
        rule_meta = "    meta:\n"
        rule_meta += "        author = \"ditekSHen\"\n"
        rule_meta += "        description = \"Detects executables signed with stolen, revoked or invalid certificates\"\n"
        rule_meta += "        thumbprint = \"%s\"\n" % cert["thumbprint"].lower()
        rule_meta += "        reason = \"%s\"\n" % cert["reason"]
        rule_meta += "        reference = \"https://bazaar.abuse.ch/faq/#cscb\"\n"
        rule_condition = "    condition:\n"
        rule_condition += "        uint16(0) == 0x5a4d and\n"
        rule_condition += "        for any i in (0..pe.number_of_signatures): (\n"
        rule_condition += "            pe.signatures[i].subject contains \"%s\" and\n" % cert["subject_cn"]
        rule_condition += "            pe.signatures[i].serial == \"%s\"\n" % ':'.join(cert["serial_number"][i:i + 2] for i in range(0, len(cert["serial_number"]), 2)).lower()
        rule_condition += "        )\n"
        rule_end = "}\n\n"

        rules += rule_name + rule_meta + rule_condition + rule_end

    fw.write(rules)

    try:
        fw.close()
    except IOError:
        print("Could not close output Yara rules file")

def main():
    usage_text = '''Example Usage:
      mbcscb_to_yara.py                           -  Download CSCB CSV file from URL and write Yara rules file using default file name (defaults)
      mbcscb_to_yara.py -o name.yar               -  Download CSCB CSV file from URL and save generated Yara rules file using custom name
      mbcscb_to_yara.py -i cscb.csv               -  Read local CSCB CSV file and write Yara rules file using default file name
      mbcscb_to_yara.py -i cscb.csv  -o name.yar  -  Read local CSCB CSV file and and save generated Yara rules file using custom name'''

    parser = argparse.ArgumentParser(description='Generate Yara rules from Abuse.ch MalwareBazar Code Signing Certificate Blocklist (CSCB)', 
                                     epilog=usage_text, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-i', '--input', type=str, metavar='INPUT', required=False, action='store', help='Input CSCB CSV local file',)
    parser.add_argument('-o', '--output', type=str, metavar='OUTPUT', required=False, default='certificates.yar', help='Output Yara rules file name')
    args = parser.parse_args()

    cert_data = parse_csv(args.input)
    if len(cert_data) > 0:
        write_yara(cert_data, args.output)
    else:
        print("No certificate IOCs found, or something went wrong!")

if __name__ == "__main__":
    main()
